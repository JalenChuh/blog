---
title: P1194 买礼物
tags: [OI, c++]
abbrlink: 55a00e88
date: 2019-12-07 19:37:02
index_img: https://cdn.jsdelivr.net/gh/Royce2019/img/img/mmja0WJK2vfsEoxNP8=g8mcUq63tzzBNoDs6fuu1Zt0HQ151.jpeg
---

## [P1194买礼物](https://www.luogu.com.cn/problem/P1194)

<!--more-->

![ng](https://i.loli.net/2019/12/07/utgrMOeYfSkZD4P.png)

~~典型阅读理解题~~

B个商品，都是A元..........

一道最小生成树题，非常佩服出题者的思想%%%

谁能把买东西和最小生成树结合起来呢（最短路写a+b的大佬除外）

好题啊，在机房写的时候，几位巨佬都说是好题

认真读题发现``x-y``的边权其实就是买了之后再买y的价格

或者买了y之后再买x的价格

那这样就很好做了

不过这题的输入和普通的题不一样，普通题给的是一组一组的边，而这题给了个邻接矩阵 ，为了方便我在输入的时候转成了用结构体来存


```cpp
struct Edge {
    int u,v,w;
}edge[MAXM];
//B为邻接矩阵的边长 
for(int i=1;i<=B;i++)
        for(int j=1;j<=B;j++) {
            cin >> t;
            if(i==j) continue;
            ++cnt;
            if(t==0) edge[cnt].w = A;
            else edge[cnt].w = t;
            edge[cnt].u = i;
            edge[cnt].v = j;
        }
```

存图完成，接下来跑一遍`` kruskal ``就ok了

```cpp
int find(int x) {
    if(f[x]==x)
        return x;
    return f[x] = find(f[x]);
}
bool cmp(Edge a,Edge b) {
    return a.w < b.w;
}

for(int i=1;i<=B;i++)
	f[i] = i;
sort(edge+1,edge+cnt+1,cmp);
for(int i=1;i<=cnt;i++) {
	if(sum+1==B)
        break;
    int x = find(edge[i].u);
    int y = find(edge[i].v);
    if(x!=y) {
        f[x] = y;
        sum++;
        ans += edge[i].w;
    }
```

这么简单？当然不可能，这时候再认真思考下``ans``存的是什么？

边的权值相加，那权值表示商品的价格，可总共B个商品，但我们直连了B-1条边，所以最后还要加上一个商品的原价A。

那么让``ans``的初值为A即可

综上，把代码合起来，整理下就ok了。

然后我就90分了QAQ

最后一个点wa了？

下个测试点

> 输入数据
>
> 3 3
> 0 4 4
> 4 0 4
> 4 4 0
>
> 输出数据
>
> 9

问题马上就出来了，商品原价3元，可买了某一个再买另一个居然还要4块？？？~~促销不应该更便宜吗~~

那既然这样，当权值大于A的时候就把A当作权值，修改下存图的代码就好了

```cpp
for(int i=1;i<=B;i++)
        for(int j=1;j<=B;j++) {
            cin >> t;
            if(i==j) continue;
            cnt++;
            if(t==0 || t>A) edge[cnt].w = A;
            else edge[cnt].w = t;
            edge[cnt].u = i;
            edge[cnt].v = j;
        }
```

最后附上AC代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#define MAXN 50000
#define MAXM 25000000
using namespace std;

int t,A,B,cnt,ans,sum;
int f[MAXN];
struct Edge {
    int u,v,w;
}edge[MAXM];

int find(int x) {
    if(f[x]==x)
        return x;
    return f[x] = find(f[x]);
}
bool cmp(Edge a,Edge b) {
    return a.w < b.w;
}

int main() {
    cin >> A >> B;
    for(int i=1;i<=B;i++)
        for(int j=1;j<=B;j++) {
            cin >> t;
            if(i==j) continue;
            cnt++;
            if(t==0 || t>A)//注意t>A则存入A
                edge[cnt].w = A;
            else
                edge[cnt].w = t;
            edge[cnt].u = i;
            edge[cnt].v = j;
        }
    ans += A;//注意ans的初值
    for(int i=1;i<=B;i++)
        f[i] = i;
    sort(edge+1,edge+cnt+1,cmp);
    for(int i=1;i<=cnt;i++) {
        if(sum+1==B)
            break;
        int x = find(edge[i].u);
        int y = find(edge[i].v);
        if(x!=y) {
            sum++;
            f[x] = y;
            ans += edge[i].w;
        }
    }
    cout << ans;
    return 0;
}
```

