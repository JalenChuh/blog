---
title: P3385【模板】负环
tags: [OI, c++]
abbrlink: fd36a626
date: 2019-11-29 00:00:00
index_img: https://cdn.jsdelivr.net/gh/Royce2019/img/img/513f1a18457dcd5dfbc47.jpg
---

## [P3385【模板】负环]( https://www.luogu.com.cn/problem/P3385 )

方法很简单，我用的``SPFA``，新增一个数组存每个点的入队次数，当某点的入队次数超过点的总数n，即说明存在负环。

<!--more-->

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#define MAXN 500100
#define MAXM 500010
const int INF = 1e9;
using namespace std;

int n,m,u,v,w,cnt,T;
int head[MAXN],dis[MAXN],vis[MAXN],num[MAXN];
struct Edge {
	int to,next,w;
}edge[MAXM<<1];//相当于MAXM*2
queue <int> q;

bool spfa() {
	fill(dis+1,dis+n+1,INF);
    memset(vis,0,sizeof(vis));
    memset(num,0,sizeof(num));
	while(!q.empty()) q.pop();
	
	q.push(1);
	vis[1] = 1;
	dis[1] = 0;
	
	while(!q.empty()){
		int u = q.front();
		q.pop();
		vis[u] = 0;
		
		for(int i=head[u];i;i=edge[i].next) {
			int v = edge[i].to;
			if(dis[v]>dis[u]+edge[i].w) {
				dis[v] = dis[u] + edge[i].w;
				if(!vis[v]) {
					q.push(v);
					vis[v] = 1;
					num[v]++;
					if(num[v]>n)
						return 1;
				}
			}	
		}
	}
	return 0;
}

void add(int u,int v,int w) {
	edge[++cnt].to=v;
	edge[cnt].w=w;
	edge[cnt].next=head[u];
	head[u]=cnt;
}

int main() {
	cin >> T;
	while(T--) {
		cin >> n >> m;
		memset(head,0,sizeof(head));
		for(int i=1;i<=m;i++) {
			cin >> u >> v >> w;
			if(w>=0) add(v,u,w);
			add(u,v,w);
		}
		if(spfa())
			cout <<"YE5"<<endl;
		else
			cout <<"N0"<<endl;
	}
	return 0;
}
```

需要注意的是**若w<0则为单向，否则双向**。所以w为0时为``双向边``。当时被卡了半天emm

至此蓝题++

[例题传送门](https://royce2019.github.io/P2136/)